// Includes
#include "LookUpTables.compute"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel MarchingCubes

struct Triangle {
	float3 vertex0;
	float3 vertex1;
	float3 vertex2;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float> densityData;
AppendStructuredBuffer<Triangle> triangleBuffer;

// voxel data
int chunkSize;
int numPointsPerAxis;

int indexFromCoord(int x, int y, int z, int w) {
	return z * w * w + y * w + x;
}

void FillCube(float x, float y, float z, out float cube[8]) {
	float3 pos = float3(x, y, z);
	float3 corner;

	for (int i = 0; i < 8; i++) {
		corner = pos + cornerTable[i];
		cube[i] = densityData[corner.z * numPointsPerAxis * numPointsPerAxis + corner.y * numPointsPerAxis + corner.x];
	}
}

[numthreads(8,8,8)]
void MarchingCubes (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numPointsPerAxis - 1 || id.y >= numPointsPerAxis - 1 || id.z >= numPointsPerAxis - 1) {
		return;
	}

	float3 pos = id.xyz;
	// Cube, 8 corners
	float cube[8];

	int cubeIndex = 0;

	//Find which corners / vertices are inside or outside the surface
	FillCube(pos.x, pos.y, pos.z, cube);

	for (int v = 0; v < 8; v++)
	{
		if (cube[v] < 0) // Shifts 1 to left by 'v' bits. v=3 -> 0000 1000 = 8
			cubeIndex |= 1 << v;
	}


	// If the configuration of this cube is 0 or 255 (completely inside the terrain or completely outside of it) we don't need to do anything.
	if (cubeIndex == 0 || cubeIndex == 255)
		return;

	// Find which edges are intersected by the surface
	//edgeIndex = edgeTable[flagIndex]; // returns 12 bit number
	
	// Find right set of triangles. Super advanced loop
	for (int i = 0; triangleTable[cubeIndex][i] != -1; i += 3)
	{	
		float3 vert0a = pos + cornerTable[edgeConnection[triangleTable[cubeIndex][i]].x];
		float3 vert0b = pos + cornerTable[edgeConnection[triangleTable[cubeIndex][i]].y];

		float3 vert1a = pos + cornerTable[edgeConnection[triangleTable[cubeIndex][i + 1]].x];
		float3 vert1b = pos + cornerTable[edgeConnection[triangleTable[cubeIndex][i + 1]].y];

		float3 vert2a = pos + cornerTable[edgeConnection[triangleTable[cubeIndex][i + 2]].x];
		float3 vert2b = pos + cornerTable[edgeConnection[triangleTable[cubeIndex][i + 2]].y];

		// Create vertex in middle of each edge
		float3 vert0 = (vert0a + vert0b) * 0.5f;
		float3 vert1 = (vert1a + vert1b) * 0.5f;
		float3 vert2 = (vert2a + vert2b) * 0.5f;

		// Add vertices to vertex buffer, then add 
		// their index to the triangles buffer in grps of 3.
		Triangle tri;
		tri.vertex0 = vert0;
		tri.vertex1 = vert1;
		tri.vertex2 = vert2;

		triangleBuffer.Append(tri);
	}
}
